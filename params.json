{
  "name": "Node-helium",
  "tagline": "NodeJS front end for Helium key-value store",
  "body": "![Node-Helium logo](node-heliumLogo.png)\r\n# node-helium\r\nNode-Helium lets you use Levyx's [Helium](http://www.levyx.com/content/helium-overview) datastore with Node.js.\r\nUsing `node-helium` is nearly identical to using Helium, with a few notable quirks.\r\n\r\n**This is a trial version**, the package will automatically stop working after two months.\r\n\r\n## Supported Operating Systems\r\n* CentOS 7.x and RHEL 7.x\r\n\r\n## Installing\r\n* Install [Node.js](https://nodejs.org/en/download/package-manager/) v4.x (LTS)\r\n* Create a directory for your project.\r\n* Download the `node-helium.tar.gz` file [here](http://packages.levyx.com/public/bindings), selecting the particular build for your operating system.\r\n```bash\r\n  wget http://packages.levyx.com/public/bindings/node-helium_centos7.tar.gz\r\n```\r\n* Then call the following. If you downloaded a package for a different OS, change the filename after `install`\r\n```bash\r\nnpm install node-helium_centos7.tar.gz\r\n```\r\n* You will be presented with a EULA, you can press `q` to skip to the end. Agree and follow the prompts to continue the installation.\r\n\r\n* You should now see the `node-modules` directory with `node-helium` inside it. The module is ready.\r\n\r\n---\r\n\r\n**For more detailed documentation**, see the `README` inside the `node-helium` package. You may also refer to the `helium.pdf` document. Even though the PDF is for Helium's native C implementation, the functions are the same unless otherwise noted.\r\n\r\n## Quick Usage\r\nHelium requires a device to write to. If you do not want to use a dedicated device, you can create a file and use it to test. The default test configuration has this file at `/tmp/4g`.\r\n\r\n```bash\r\ndd if=/dev/zero of=/tmp/4g bs=1k count=$((4 * 1024 * 1024))\r\n```\r\n\r\nNow you can write your code, create `example.js` inside your project directory and copy-paste the following examples to it. Run the program with:\r\n```bash\r\nnode example.js\r\n```\r\n\r\n\r\n#### Example 1\r\nInsert and read a simple value.\r\n```javascript\r\nvar he = require( 'node-helium' );\r\n\r\nvar OPEN_SETTINGS = he.HE_O_CREATE | he.HE_O_VOLUME_CREATE | he.HE_O_VOLUME_TRUNCATE;\r\n\r\nvar myHe = he.open( 'he://.//tmp/4g', 'DATASTORE', OPEN_SETTINGS, null );\r\n\r\nvar myKey = new Buffer( 'peanutbutter', 'utf-8' );\r\nvar myVal = new Buffer( 'jelly', 'utf-8' );\r\nvar testItem = he.make_item( myKey, myVal, 12, 5 );\r\nhe.insert( myHe, testItem );\r\n\r\nvar lookKey = new Buffer( 'peanutbutter', 'utf-8' );\r\nvar receiveBuf = new Buffer( 50 );\r\nvar lookupItem = he.make_item( lookKey, receiveBuf, 12, 5 );\r\nhe.lookup( myHe, lookupItem, 0, 5 );\r\n\r\nconsole.log( receiveBuf.toString( 'utf-8', 0, 5 ) ); // This will be 'jelly'\r\n\r\nhe.close( myHe );\r\n```\r\n#### Example 2\r\nWorking with transactions. This example has more advanced usage, namely reuse of buffers.\r\n```javascript\r\nvar he = require( 'node-helium' );\r\n\r\nvar OPEN_SETTINGS = he.HE_O_CREATE | he.HE_O_VOLUME_CREATE | he.HE_O_VOLUME_TRUNCATE;\r\n\r\nvar myHe = he.open( 'he://.//tmp/4g', 'DATASTORE', OPEN_SETTINGS, null );\r\n\r\nvar keyBuf = new Buffer( 50 );\r\nvar valBuf = new Buffer( 50 );\r\n\r\nkeyBuf.write( 'peanutbutter', 'utf-8' );\r\nvalBuf.write( 'jelly', 'utf-8' );\r\nvar testItem = he.make_item( keyBuf, valBuf, 12, 5 );\r\n\r\nhe.insert( myHe, testItem );\r\n\r\nvar myTransaction = he.transaction( myHe );\r\n\r\nvalBuf.write( 'avocado', 'utf-8' );\r\ntestItem.set_val_len( 7 );\r\nhe.update( myTransaction, testItem );\r\n\r\nhe.commit( myTransaction );\r\n\r\nvar ret = he.lookup( myHe, testItem, 0, 7 );\r\n\r\nconsole.log( testItem.val().toString() ); // Prints 'avocado'\r\n\r\nhe.close( myHe );\r\n```\r\n\r\n#### REST Example\r\nSee the [`examples`](https://github.com/levyx/node-helium/tree/master/examples/rest) directory of this repo.\r\n\r\n## Performance Benchmarking\r\nExecute the following to run a performance test with `node-helium`. Substitute `he://.//tmp/4g` with your own Helium URL. Remember that Node.js is always single threaded, so the test always runs on one thread.\r\n```javascript\r\nnode scripts/performanceTest.js -d 'he://.//tmp/4g' -o 1000000 -v 100\r\n```\r\n\r\n## Performance  \r\nThe following shows some sample performance numbers on Google Cloud.\r\n\r\n---\r\n\r\n**GCloud n1-highcpu-32** 28.8 GB Memory  \r\n1x 375GB Local SSD  \r\n**1000000** operations | **1KB** obj size\r\n\r\nOperations per sec.  \r\nInserts: **480K**  \r\nSeq Lookup: **800K**  \r\nRand Lookup: **500K**  \r\nDeletes: **1000K**  \r\n\r\n---\r\n\r\n**GCloud n1-standard-1** 3.75 GB Memory  \r\n1x 375GB Local SSD  \r\n**1000000** operations | **1KB** obj size\r\n\r\nMillions of operations per sec.  \r\nInserts: **350K**  \r\nSeq Lookup: **750K**  \r\nRand Lookup: **400K**  \r\nDeletes: **800K**  \r\n\r\n\r\n## API Usage\r\n**Look at Helium.pdf**, it details how Helium works. Most of `node-helium`'s functions are the same as Helium's native C API, however, there are some important differences:\r\n1. `node-helium` makes use of a C style api. This means the javascript API looks very similar to Helium's native C API.\r\n2. Javascript does not have structs. So things that are structs tend to be objects.\r\n3. Not all objects in `node-helium` are 'real' Javascript objects. They are pointers to special objects that can be passed between Javascript and C, so you cannot directly access their properties, you must use their functions to get and set values. Look at `he_item`.\r\n\r\nBelow are specific functions that are different or unique to `node-helium`.\r\n\r\n## he\\_enumerate\r\nWorks as expected, just provide a javascript function for the callback.\r\n```javascript\r\nvar he = require( 'node-helium' );\r\n\r\nvar OPEN_SETTINGS = he.HE_O_CREATE | he.HE_O_VOLUME_CREATE | he.HE_O_VOLUME_TRUNCATE;\r\nvar myHe = he.open( 'he://.//tmp/4g', 'DATA1', OPEN_SETTINGS, null );\r\nvar myHe2 = he.open( 'he://.//tmp/4g', 'DATA2', he.HE_O_CREATE | he.HE_O_VOLUME_CREATE, null );\r\n\r\nvar callback = function( err, datastoreList ) {\r\n  console.log( datastoreList ); // datastoreList is a list of datastore names.\r\n}\r\n\r\nvar ret = he.enumerate( 'he://.//tmp/4g', callback );\r\n\r\nhe.close( myHe );\r\nhe.close( myHe2 );\r\n```\r\n\r\n## he\\_item\r\n`he_item` structs in Helium need to be built by a function in `node-helium`.\r\n\r\n```javascript\r\nvar keyBuf = new Buffer( 50 );\r\nvar valBuf = new Buffer( 50 );\r\nkeyBuf.write( 'peanutbutter', 'utf-8' );\r\nvalBuf.write( 'jelly', 'utf-8' );\r\nvar testItem = he.make_item( keyBuf, valBuf, 12, 5 ); // testItem can be used like he_item\r\n\r\ntestItem.key(); // Gets the key buffer, size determined by the key_len value of the item.\r\ntestItem.val(); // Gets the value buffer, size determined by the val_len value of the item.\r\ntestItem.key( 5 ); // Gets 5 bytes of the key buffer.\r\ntestItem.val( 5 ); // Gets 5 bytes of the val buffer.\r\ntestItem.key_len(); // Gets the key length associated with the item.\r\ntestItem.val_len(); // Gets the val length associated with the item.\r\ntestItem.set_key_len( 5 ); // Set the key length to 5.\r\ntestItem.set_val_len( 5 ); // Set the val length to 5.\r\n\r\n// Only write to buffers you get with key() or val(), do not set them.\r\ntestItem.key() = new Buffer( 'peanutbutter' ); // DO NOT DO THIS!\r\ntestItem.key().write( 'peanutbutter' ); // Do this instead.\r\n```\r\n\r\n## he\\_iterate\r\nThe `he_iterate` function is indirectly supported though the `func.iterate` function which implements the iteration logic with the `he_next` Helium command. Even though `he_item` is not returned, `key` and `val` still point to the buffers in the `he_item`, so modifying them will update the underlying `he_item`.\r\n```javascript\r\nvar he = require( 'node-helium' );\r\n\r\nvar OPEN_SETTINGS = he.HE_O_CREATE | he.HE_O_VOLUME_CREATE | he.HE_O_VOLUME_TRUNCATE;\r\nvar myHe = he.open( 'he://.//tmp/4g', 'DATASTORE', OPEN_SETTINGS, null );\r\n\r\nvar myKey = new Buffer( 'aaaa', 'utf-8' );\r\nvar myVal = new Buffer( '11111', 'utf-8' );\r\nvar testItem = he.make_item( myKey, myVal, 4, 5 );\r\nhe.insert( myHe, testItem );\r\n\r\nvar myKey2 = new Buffer( 'bbbb', 'utf-8' );\r\nvar myVal2 = new Buffer( '22222', 'utf-8' );\r\nvar testItem2 = he.make_item( myKey2, myVal2, 4, 5 );\r\nhe.insert( myHe, testItem2 );\r\n\r\nvar myKey3 = new Buffer( 'cccc', 'utf-8' );\r\nvar myVal3 = new Buffer( '33333', 'utf-8' );\r\nvar testItem3 = he.make_item( myKey3, myVal3, 4, 5 );\r\nhe.insert( myHe, testItem3 );\r\n\r\nvar counter = 0;\r\nhe.func.iterate( myHe, 4, 5, function( keySize, valueSize, key, val ) {\r\n  // This will execute once for every key in the datastore.\r\n  console.log( key.toString() );\r\n});\r\n\r\nhe.close( myHe );\r\n```\r\n\r\n## he\\_open\r\nUse a javascript object for the `he_env` struct options.\r\n```javascript\r\nvar he = require( 'node-helium' );\r\n\r\nvar OPEN_SETTINGS = he.HE_O_CREATE | he.HE_O_VOLUME_CREATE | he.HE_O_VOLUME_TRUNCATE;\r\nvar myHe = he.open( 'he://.//tmp/4g', 'DATASTORE', OPEN_SETTINGS, {'fanout': 30, 'retry_count': 400} );\r\n\r\nhe.close( myHe );\r\n```\r\n\r\n## he\\_stats\r\nReturns a javascript object with the info. On error, this function will return an object with `error` property set accordingly.\r\n```javascript\r\nvar he = require( 'node-helium' );\r\n\r\nvar OPEN_SETTINGS = he.HE_O_CREATE | he.HE_O_VOLUME_CREATE | he.HE_O_VOLUME_TRUNCATE;\r\nvar myHe = he.open( 'he://.//tmp/4g', 'DATASTORE', OPEN_SETTINGS, null );\r\n\r\nvar myKey = new Buffer( 'peanutbutter', 'utf-8' );\r\nvar myVal = new Buffer( 'jelly', 'utf-8' );\r\nvar testItem = he.make_item( myKey, myVal, 12, 5 );\r\nhe.insert( myHe, testItem );\r\n\r\nvar stats = he.stats( myHe );\r\nconsole.log( stats ); // Will print out the stats object.\r\nconsole.log( stats.name ); // Will print out 'DATASTORE'.\r\n\r\nhe.close( myHe );\r\n\r\nvar errorStats = he.stats( myHe ); // Calling this again after closing the datastore will fail.\r\nconsole.log( errorStats.error ); // This will equal the error code\r\n```\r\n\r\n## he\\_version\r\nTakes no arguments for simplicity. Will return a string with the version of Helium node-helium is using.\r\n\r\n## Common Errors\r\n#### I seem to get `HE_ERR_ITEM_NOT_FOUND` when I have bigger/more keys even though my code is the same.\r\nMake sure you use `item.set_key_len()` if you change the value of an item's key after it is created.\r\n```javascript\r\nfor ( var i = 0; i < 1000000; ++i ) {\r\n  var keyString = 'key_' + i.toString();\r\n  testItem.set_key_len( keyString.length ); // THIS LINE IS IMPORTANT!\r\n  myKey.write( keyString, 0 ); // ...Since we are changing the length of the key when `i` gets big.\r\n\r\n  //\r\n  // ...\r\n  // rest of code down here\r\n\r\n\r\n}\r\n```\r\n\r\n---\r\n\r\nBuffers and pointers in Node.js have some quirks. Javascript likes to aggressively garbage collect, so if you reassign the buffer pointer of an item, you will get strange results.\r\n```javascript\r\nvar myKey = new Buffer( 'peanutbutter', 'utf-8' );\r\nvar myVal = new Buffer( 'jelly', 'utf-8' );\r\nvar testItem = he.make_item( myKey, myVal, 12, 5 );\r\nhe.insert( myHe, testItem );\r\n\r\nmyKey = new Buffer( 'peanutbutter', 'utf-8' ); // Do not reassign myKey to a new buffer.\r\nmyVal = new Buffer( 50 ); // Do not reassign myVal to a new buffer\r\nhe.lookup( myHe, testItem, 0, 5 );\r\n\r\nconsole.log( myVal.toString( 'utf-8', 0, 5 ) ); // This will print NOTHING, you would expect 'jelly'\r\nconsole.log( testItem.val().toString( 'utf-8', 0, 5 ) ); // But this WILL print 'jelly'\r\n```\r\nIn summary, do not reassign buffers, instead, just rewrite to the buffers you initially assigned (see example 2 above).\r\n\r\n---\r\n\r\n`key()` and `val()` functions for `he_item` will return a buffer with a length set to the size of the `he_item`'s current `key_len` and `val_len` respectively. But the buffer will still point to the **same** data used to construct the `he_item` initially. The following example illustrates this.\r\n```javascript\r\nvar myKey = new Buffer( 'peanutbutter', 'utf-8' );\r\nvar myVal = new Buffer( 'jelly', 'utf-8' );\r\nvar testItem = he.make_item( myKey, myVal, 12, 5 );\r\n\r\ntestItem.set_val_len( 3 );\r\n\r\nconsole.log( testItem.val().toString() ); // This will print 'jel'\r\n\r\ntestItem.val().write( 'rocks' );\r\n\r\nconsole.log( testItem.val().toString() ); // This will print 'roc' from the `testItem.val()`\r\nconsole.log( myVal.toString() ); // This will print 'rocly' from the `myVal` buffer....what!?\r\n```\r\nNotice how `val()` only returns part of the `he_item` value, but still points to the original data used in `myVal`.\r\nThe references are the same, but the objects are not!\r\n\r\n\r\n# Issues/Bugs?\r\nCreate an issue on this repo, or email `info@levyx.com`\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}